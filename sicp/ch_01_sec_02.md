## Procedures and the Processes They Generate

Now that we have ran operations, combined them and abstracted them in compound procedures, it looks as if we know programming.

How ever we have but learned how to move pieces on a chess board. We are far from understanding the tactics and strategy requires to become a player.

We lack the experience to predict the consequences of making a move.


Ability to visualize the consequences of the actions under the consideration is crucial to becoming an expert programmer.
Just as in any synthetic creative activity.

In becmoing an expert photographer, for example, one must learn how to look at a scene and know how dark each region will appear
on a print for each possible choice of exposure and development conditions.

Only then photographer can reason backwards to create the scene he pleases.


IN this section we will examine some common "shapes" for processes generated by simple procedures.

### 2.1 Linear iterative and recursive processes

Factorial


### 2.2 Tre Recursion

Fibonacci

#### Counting Change Change


### 2.3 Orders of Growth

### 2.4 Exponentiation

Consider the problem of computing the exponential of a given number.

```
(define (expt b n)
    (if (= n 0))
        1
        (* n (expt b (- n 1))))


(define (expt b n)
    (define (expt_int b n curr res)
        (if (= n curr)
            res
            (expt_int b n (+ 1 curr) (* res b))))
    (expt_int b n 0 1)
    )
```

Use a little arithmetic trick to make this logarithmic complexity.

(b^n)^2 = b^2n..

^2 = b^2n..

^2 = b^2n..

#### 5Head ex 2.19


### 2.5 Greates Common Divisor

Idea of GCD Algo is that if _r_ is the remainder when _a_ is dividied by _b_ 
then the common divisors of a and b are precisely the same as the common divisors of b and r.

Thus, GCD(a,b) = GCD(b,r)


#### 5Head Lame's Theorem

If Euclid's algo takes k steps to compute the GCD of some pair, 
then the smaller number must be greater or equal to the kth Fibonacci number.

Proof:

Some pair (a_k, b_k) where a_k >= b_k for which Euclid's algo terminate in k steps.

Claim: 

if (a_k+1, b_k+1) -> (a_k, b_k) -> (a_k-1, b_k-1) are successive pairs in the reduction process, then we must have b_k+1 >= b_k + b_k-1.

To verify the claim, consider reduction step is defined by:

a_k-1 = b_k and b_k-1 = a_k mod b_k

Expanding second step: b_k-1 = a_k mod b_k ---> a_k = b_k * q + b_k-1

This shows a_k >= b_k + b_k-1

In the previous step we had b_k+1 = a_k



